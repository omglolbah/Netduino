using System;
using Microsoft.SPOT.Hardware;
using Netduino.Extender.TransferAdapters;

namespace NetduinoRGBController
{
    /// <summary>
    ///     TMP100 I2C control class. Texas Instruments TMP100.
    /// </summary>
    public class TMP100
    {
        // Note: A constructor summary is auto-generated by the doc builder.

        /// <summary>
        ///     Resolution used to report temperature.
        /// </summary>
        public enum ResolutionBits
        {
            /// <summary>
            ///     9 bit resolution (0.5 C)
            /// </summary>
            R05, // = 0x000,
            /// <summary>
            ///     10 bit resolution (0.25 C)
            /// </summary>
            R025, // = 0x020,
            /// <summary>
            ///     11 bit resolution (0.125 C)
            /// </summary>
            R0125, // = 0x040,
            /// <summary>
            ///     12 bit resolution (0.0625 C)
            /// </summary>
            R00625 // = 0x060
        }

        /// <summary>
        ///     Configurable module address.
        /// </summary>
        public enum Address
        {
            /// <summary>
            ///     1001000
            /// </summary>
            A1001000,

            /// <summary>
            ///     1001001
            /// </summary>
            A1001001,

            /// <summary>
            ///     1001010
            /// </summary>
            A1001010,

            /// <summary>
            ///     1001011
            /// </summary>
            A1001011,

            /// <summary>
            ///     1001100
            /// </summary>
            A1001100,

            /// <summary>
            ///     1001101
            /// </summary>
            A1001101,

            /// <summary>
            ///     1001110
            /// </summary>
            A1001110,

            /// <summary>
            ///     1001111
            /// </summary>
            A1001111
        }

        private const int I2CClockRateKHz = 400;
        private const int I2CTimeout = 1000;

        private Address _address = Address.A1001000;
        private ResolutionBits _bits = ResolutionBits.R05;
        private I2CDevice.Configuration _i2C;
        private I2CAdapter _i2Cadapter = I2CAdapter.Instance;

        private bool _lowPowerMode = false;
        private ushort _chipAddress = 0x48;

        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public TMP100(ushort I2CBuschipAddress)
        {
            _i2C = new I2CDevice.Configuration(I2CBuschipAddress, I2CClockRateKHz);
        }

        /// <summary>
        ///     Gets or sets the TMP100 Low Power Mode.
        /// </summary>
        public bool LowPowerMode
        {
            get { return _lowPowerMode; }

            set
            {
                _lowPowerMode = value;

                if (_lowPowerMode)
                {
                    WriteRegister(0x01);
                }
                else
                {
                    WriteRegister(0x00);
                }
            }
        }

        /// <summary>
        ///     Gets or sets the TMP100's Address.
        /// </summary>
        public Address SensorAddress
        {
            /*
             *   ADD1  ADD0      Slave Address
             *     0     0       1001000  0x48
             *     0   float     1001001  0x49
             *     0     1       1001010  0x4A
             *     1     0       1001100  0x4C
             *     1   float     1001101  0x4D
             *     1     1       1001110  0x4E
             *   float   0       1001011  0x
             *   float   1       1001111  0x4F
             */
            get { return _address; }
            set
            {
                _address = value;

                switch (value)
                {
                    case Address.A1001000:
                        _chipAddress = 0x48;
                        break;
                    case Address.A1001001:
                        _chipAddress = 0x49;
                        break;
                    case Address.A1001010:
                        _chipAddress = 0x4A;
                        break;
                    case Address.A1001011:
                        _chipAddress = 0x4B;
                        break;
                    case Address.A1001100:
                        _chipAddress = 0x4C;
                        break;
                    case Address.A1001101:
                        _chipAddress = 0x4D;
                        break;
                    case Address.A1001110:
                        _chipAddress = 0x4E;
                        break;
                    case Address.A1001111:
                        _chipAddress = 0x4F;
                        break;
                }
                _i2C = new I2CDevice.Configuration(_chipAddress, I2CClockRateKHz);
            }
        }


        /// <summary>
        ///     Gets or sets the temperature resolution.
        /// </summary>
        public ResolutionBits Resolution
        {
            get { return _bits; }
            set
            {
                _bits = value;

                byte resolution;

                switch (value)
                {
                    case ResolutionBits.R025:
                        resolution = 0x20;
                        break;
                    case ResolutionBits.R0125:
                        resolution = 0x40;
                        break;
                    case ResolutionBits.R00625:
                        resolution = 0x60;
                        break;
                    default: //ResolutionBits.R05
                        resolution = 0x00;
                        break;
                }
                WriteRegister(resolution);
            }
        }

        private void WriteRegister(Byte value)
        {
            // Create a new transaction to write a register value
            var data = new[] { (Byte)0x01, value };

            _i2Cadapter.WriteBytes(_i2C, data);
        }

        /// <summary>
        ///     Gets temperature in Celsius
        /// </summary>
        public double GetTemperature()
        {
            // Create a new transaction to read a register value
            var data = new Byte[2];

            _i2Cadapter.WriteBytes(_i2C, new byte[] { 0x00 });

            _i2Cadapter.ReadBytes(_i2C, data);
            
            sbyte msb = (sbyte)data[0];
            byte lsb = data[1];

            int temperatureSum = (msb << 4) + (lsb >> 4);

            return temperatureSum * 0.0625;
        }
    }
}